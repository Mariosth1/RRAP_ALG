import numpy as np


subsystems = 15
redundancy = 8

def obj_function(r, n):
    M = 5

    c = np.array([[33.2468, 27.5668, 13.38, 0.471, 51.2555, 82.9415, 51.8804, 77.9446, 26.8835, 85.8722, 41.8733,
                   61.6181, 90.0418, 75.5947, 88.5974],
                  [35.6054, 44.9520, 28.6889, 0.4922, 39.6833, 59.2294, 78.4996, 86.6633, 7.8195, 27.7460, 90.4377,
                   58.0131, 77.8206, 36.4524, 61.0591],
                  [13.7848, 96.7365, 86.8783, 63.0815, 75.5364, 11.8123, 97.1872, 45.0850, 3.6722, 55.395, 75.7999,
                   98.5166, 60.6308, 70.4654, 18.8802],
                  [44.1345, 25.9855, 19.2621, 12.1687, 23.9668, 28.9889, 47.8387, 25.0545, 76.9923, 53.3007, 95.0057,
                   97.9127, 37.2226, 96.9179, 42.1222],
                  [10.9891, 68.0713, 1.0164, 29.4809, 59.5441, 46.5904, 49.6226, 59.2594, 87.4070, 55.3175, 54.1269,
                   59.1341, 40.9427, 40.2141, 80.0045]
                  ])

    d = np.array([[3.2150, 3.4710, 3.3247, 2.6236, 3.4288]])

    if M == 1:
        c = c[0][:]
        d = d[0][0]
        b = d * np.sum(c)

    elif M == 5:

        b = d * np.sum(c, axis=1)

    R = 1 - (1 - r) ** n
    Q = 1 - R

    solution_quality = R[0][0] * R[0][1] * R[0][2] * R[0][3] * R[0][4] * R[0][5] + R[0][8] * R[0][9] * R[0][10] * \
                    R[0][11] * R[0][12] * R[0][13] * R[0][14] * (Q[0][0] + R[0][0] * Q[0][1] + R[0][0] * R[0][1] * \
                    Q[0][2] + R[0][0] * R[0][1] * R[0][2] * Q[0][3] + R[0][0] * R[0][1] * R[0][2] * R[0][3] * Q[0][4] +\
                    R[0][0] * R[0][1] * R[0][2] * R[0][3] * R[0][4] * Q[0][5]) + R[0][3] * R[0][4] * R[0][5] * R[0][6] * \
                    R[0][8] * R[0][9] * (Q[0][10] + R[0][10] * Q[0][11] + R[0][10] * R[0][11] * Q[0][12] +\
                    R[0][10] * R[0][11] * R[0][12] * Q[0][13] + R[0][10] * R[0][11] * R[0][12] * R[0][13] * Q[0][14]) *\
                    (Q[0][0] + R[0][0] * Q[0][1]) + ((Q[0][0] + R[0][0] * Q[0][1]) * (Q[0][2] + R[0][2] * Q[0][3] +\
                    R[0][2] * R[0][3] * Q[0][6]) + R[0][0] * R[0][1] * Q[0][6] * (Q[0][2] + R[0][2] * Q[0][3])) *\
                    (Q[0][12] + R[0][12] * Q[0][13] + R[0][12] * R[0][13] * Q[0][14]) * R[0][4] * R[0][5] * R[0][7] *\
                    R[0][8] * R[0][9] * R[0][10] * R[0][11] + R[0][0] * R[0][1] * R[0][4] * R[0][5] *R[0][6] * R[0][7] * \
                    R[0][10] * R[0][11] * (R[0][8] * R[0][9] + Q[0][8] + R[0][8] * Q[0][9]) * (Q[0][2] + R[0][2] *\
                    Q[0][3]) * (Q[0][12] + R[0][12] * Q[0][13] + R[0][12] * R[0][13] * Q[0][14]) + (Q[0][4] + R[0][4] *\
                    Q[0][5]) * ((Q[0][6] + R[0][6] * Q[0][10] + R[0][6] * R[0][10] * Q[0][11]) * (Q[0][8] + R[0][8] *\
                    Q[0][9]) + R[0][8] * R[0][9] * (Q[0][10] + R[0][10] * Q[0][11])) * R[0][0] * R[0][1] * R[0][2] * \
                    R[0][3] * R[0][7] * R[0][12] * R[0][13] * R[0][14] + R[0][0] * R[0][1] * R[0][6] * R[0][10] * \
                    R[0][11] * R[0][12] * R[0][13] * R[0][14] * (Q[0][8] + R[0][8] * Q[0][9]) * (Q[0][2] + R[0][2] *\
                    Q[0][3] + R[0][2] * R[0][3] * Q[0][4] + R[0][2] * R[0][3] * R[0][4] * Q[0][5]) + R[0][2] * \
                    R[0][3] * R[0][6] * R[0][7] * R[0][8] * R[0][9] * R[0][12] * R[0][13] * R[0][14] * (Q[0][0] +\
                    R[0][0] * Q[0][1]) * (Q[0][10] + R[0][10] * Q[0][11]) * (Q[0][4] + R[0][4] * Q[0][5])



    if M == 5:
        c = c * n
        g = np.sum(c, axis=1)

    else:
        g = np.sum(c * n)

    if np.all(g <= b) and solution_quality < 1: solution_quality = solution_quality
    else: solution_quality = 0.0

    return solution_quality